@page "/"

@using BlazorWorker.BackgroundServiceFactory;
@using BlazorWorker.Core

@using BlazorWorker.WorkerBackgroundService
@using MudBlazor.Utilities
@using NDiscoPlus.Constants
@using NDiscoPlus.LightHandlers
@using NDiscoPlus.LightHandlers.Screen
@using NDiscoPlus.Models
@using NDiscoPlus.Shared
@using NDiscoPlus.Shared.Effects.API.Channels.Effects.Intrinsics
@using NDiscoPlus.Shared.Helpers
@using NDiscoPlus.Shared.MemoryPack
@using NDiscoPlus.Shared.Models.Color
@using NDiscoPlus.Shared.Music
@using NDiscoPlus.Shared.Models
@using NDiscoPlus.Spotify.Models
@using NDiscoPlus.Spotify.Players
@using NDiscoPlus.Components;
@using SkiaSharp
@using SpotifyAPI.Web
@using System.Diagnostics
@using System.Text.Json
@using System.Web
@using System.Globalization
@using System.Collections.Frozen
@using System.Collections.Immutable
@using System.Collections.Concurrent
@using System.Diagnostics.CodeAnalysis

@inject Blazored.LocalStorage.ILocalStorageService localStorage
@inject NavigationManager navigationManager
@inject ILogger<HomePage> logger;
@inject ILogger<SpotifyWebPlayer> playerLogger;
@inject IWorkerFactory workerFactory;
@inject IJSRuntime JSRuntime;
@inject ISnackbar Snackbar;

<PageTitle>@("NDiscoPlus" + (interpreterFps is InterpreterFPS fps ? $" - {fps.Average:0.00} fps ({fps.Min:0.00} min)" : string.Empty))</PageTitle>

<div @onmousemove="OnMouseMove" style=@AddCursorStyle("width:100vw; height:100vh; overflow: hidden;")>
    <BackgroundGradientCanvas Colors="@BestBackgroundGradientOption" />
    <MudStack AlignItems="AlignItems.Center" Justify="Justify.FlexStart" Style="padding-top:20vh;position:absolute;top:0;left:0;right:0;bottom:0;">
        @if(context is not null) {
            <MudImage
                Src="@context.Track.LargestImage.Url"
                Width="256"
                Height="256"/>
        }
        else
        {
            <div style="background:#1DB954;padding:64px">
                <MudImage
                    Src="./img/spotify_icon_white.svg"
                    Width="128"
                    Height="128"/>
            </div>
        }
        <div style="min-width:256px;">
            <MudText Style="line-height:1.0; font-size:x-large;"><b>@(context?.Track.Name ?? "Not Playing...")</b></MudText>
            @if(context is not null)
            {
                <MudText Style="font-size:medium;padding-bottom:1em">@string.Join(", ", context.Track.Artists)</MudText>
            }
        </div>
        <div style="width:80%; max-width:512px; padding-bottom:64px">
            @if(context is not null)
            {
                <MudProgressLinear
                    Value="@(context.Progress.TotalSeconds)"
                    Min="0"
                    Max="@(context.Track.Length.TotalSeconds)"
                    Rounded="true"
                    />
                <MudStack Style="" Row="true" Justify="Justify.SpaceBetween">
                    <MudText Style="line-height:2; font-size:small;">@(context.Progress.ToString(TimespanFormat))</MudText>
                    <MudText Style="line-height:2; font-size:small;">@(context.Track.Length.ToString(TimespanFormat))</MudText>
                </MudStack>
            }
        </div>
        @if (!HideUI)
        {
            <MudButton StartIcon="@Icons.Material.Rounded.Lightbulb"
                       Variant="@(IsPlaying ? Variant.Outlined : Variant.Filled)"
                       Size=Size.Large
                       Color=MudBlazor.Color.Primary
                       Disabled=@(spotify is null || playStarting)
                       OnClick=TogglePlay>
                @(IsPlaying ? "Stop" : "Play")
            </MudButton>
        }
    </MudStack>
</div>
@if (!HideUI)
{
    <MudStack Style="position:fixed; top:0; left:0; padding:16px">
        <MudIconButton Icon="@Icons.Material.Rounded.Settings"
                       Size="Size.Large"
                       OnClick="OpenSettings"
                       Disabled="IsPlaying" />
        <MudIconButton Icon="@Icons.Material.Rounded.Fullscreen"
                       Size="Size.Large"
                       OnClick="ToggleFullscreen" />
        @if (DebugEnabled)
        {
            <MudIconButton Disabled="@(lightHandling?.CurrentData is null)"
                           Icon="@Icons.Material.Rounded.BugReport"
                           Size="Size.Large"
                           OnClick="@(async () => await OpenEffectVisualizer(lightHandling!.CurrentData!))" />
        }
    </MudStack>
}
<MudStack AlignItems="AlignItems.End" Style="">
    @if(context?.NextTrack is SpotifyPlayerTrack nextTrack)
    {
        <MudPaper Elevation="8" Class="next_track_fadein" Style="position: fixed; top:24px; right: 24px; background:#000000AA; padding:16px; border-radius:16px;">
        <MudStack Row="true" AlignItems="AlignItems.Center">
            <MudImage Src=@(nextTrack.SmallestImage.Url)
                    Width="48"
                    Height="48" />
            <MudStack Spacing="0">
                <MudText Style="font-size:small; color:#FFFFFFAA">
                    Next Track
                </MudText>
                <MudText Style="line-height:1.0; font-size:x-large; white-space:nowrap; color:white">
                    @(nextTrack.Name)
                </MudText>
            </MudStack>
        </MudStack>
    </MudPaper>
    }
</MudStack>

<style>
.next_track_fadein {
    animation: fadein 2s;
}

@@keyframes fadein {
    from {
        opacity: 0;
    }

    to {
        opacity: 1;
    }
}
</style>

<script src="./Pages/HomePage.razor.js"></script>

@code {
    #if DEBUG
    public bool DebugEnabled { get; } = true;
    #else
    [SupplyParameterFromQuery(Name = "debug")]
    public bool DebugEnabled { get; init; }
#endif

    record struct PaletteGradient(NDPColorPalette Palette)
    {
        private ImmutableArray<NDPColor>? gradient = null;
        public ImmutableArray<NDPColor>? Gradient
        {
            get
            {
                gradient ??= PaletteToGradient(Palette);
                return gradient;
            }
        }
        public ImmutableArray<NDPColor> GradientMustNotBeNull
        {
            get
            {
                ImmutableArray<NDPColor>? gradient = Gradient;
                if (!gradient.HasValue)
                    throw new InvalidOperationException("Palette cannot be turned into a gradient.");
                return gradient.Value;
            }
        }

        static ImmutableArray<NDPColor>? PaletteToGradient(NDPColorPalette palette)
        {
            if (palette.Count < 4)
                return null;

            return palette.Take(4).ToImmutableArray();
        }
    }

    record LightHandlingData(
        ImmutableArray<LightHandler> Handlers,
        ImmutableArray<NDPLight> Lights,
        ScreenLightHandler ScreenLightHandlerSingleton
    )
    {
        public string? CurrentDataTrackId{ get; set; }
        public Task<Shared.Models.NDPData>? CurrentDataTask { get; set; }
        public Shared.Models.NDPData? CurrentData => CurrentDataTask?.IsCompleted == true ? CurrentDataTask.Result : null;

        public string? NextDataTrackId { get; set; }
        public Task<Shared.Models.NDPData>? NextDataTask { get; set; }
        public Shared.Models.NDPData? NextData => NextDataTask?.IsCompleted == true ? NextDataTask.Result : null;
    }

    readonly record struct FetchTask(string TrackId, Task<NDPData> Task);
    readonly record struct InterpreterFPS(double Average, double Min);

    const string TimespanFormat = @"mm\:ss";

    static readonly PaletteGradient defaultGradient = new(NDiscoPlusService.DefaultPalettes[0]);
    public IReadOnlyList<NDPColor> BestBackgroundGradientOption => lightHandling?.ScreenLightHandlerSingleton.Colors ?? TryGetTrackGradient(context?.Track)?.Gradient ?? defaultGradient.GradientMustNotBeNull;

    // cache can be big as I don't really care about how slow cache misses are since it's still magnitudes faster than when we serialize the gradient computation request to BlazorWorker
    readonly LRUCache<string, Task<PaletteGradient?>> trackIdToGradientCache = new(capacity: 25);

    LightInterpreter gradientLights = new();


    LightHandlingData? lightHandling = null;
    [MemberNotNullWhen(true, nameof(lightHandling))]
    bool IsPlaying => lightHandling is not null;
    bool playStarting = false;

    const int targetFps = 75;
    InterpreterFPS? interpreterFps;
    const int interpreterFpsFramesCount = 25;
    List<double> interpreterFpsFrames = new(capacity: interpreterFpsFramesCount);

    SpotifyClient? spotify = null;
    SpotifyPlayerContext? context = null;

    IWorkerBackgroundService<NDiscoPlusService>? ndpService = null;

    readonly List<ValueTask> lightHandlerUpdates = new();

    protected override async Task OnInitializedAsync()
    {
        StoredSpotifyRefreshToken? refreshToken = await localStorage.GetItemAsync<StoredSpotifyRefreshToken>(LocalStoragePaths.SpotifyRefreshToken);
        if (refreshToken is StoredSpotifyRefreshToken rt && NDPConstants.SpotifyScope.All(s => refreshToken.Scope.Contains(s)))
        {
            try
            {
                logger.LogInformation("Spotify login success.");
                await LoginSpotify(rt.RefreshToken);
            }
            catch (Exception e)
            {
                logger.LogError("Spotify login failed with error: '{}'. Requesting new login...", e);
                RequestLogin();
            }
        }
        else
        {
            logger.LogInformation(
                "Requesting new Spotify login.\n- refresh token null: {}\n- old scope: {}\n- new scope: {}",
                refreshToken is null,
                refreshToken is null ? "null" : string.Join(' ', refreshToken.Scope),
                NDPConstants.SpotifyScope
            );
            RequestLogin();
        }

        var ndpWorker = await workerFactory.CreateAsync();
        ndpService = await ndpWorker.CreateBackgroundServiceAsync<NDiscoPlusService>(options =>
        {
            options.UseCustomExpressionSerializer(typeof(CustomSerializeLinqExpressionJsonSerializer));
        });

        _ = StartPlayer();
    }

    [JSInvokable] // Called by: toggleNDiscoPlusFullscreen()
    public void WakeLockStateChanged(bool enabled)
    {
        if (enabled)
        {
            Snackbar.Add("Wake Lock Enabled", Severity.Warning, static config =>
            {
                config.Icon = Icons.Material.Rounded.Brightness5;
                config.IconColor = Color.Warning;
                config.SnackbarVariant = Variant.Outlined;
                config.DuplicatesBehavior = SnackbarDuplicatesBehavior.Allow;
            });
        }
        else
        {
            Snackbar.Add("Wake Lock Disabled", Severity.Normal, static config =>
            {
                config.Icon = Icons.Material.Rounded.Brightness4;
                config.IconColor = MudBlazor.Color.Primary;
                config.SnackbarVariant = Variant.Outlined;
                config.DuplicatesBehavior = SnackbarDuplicatesBehavior.Allow;
            });
        }
    }

    #region Hide Mouse & UI Buttons
    object hideCursorLock = new();
    bool _hideCursor = false;

    uint hideCursorTimerSeconds = 0; // use uint so that we never overflow (overflow time is more than 136 years)
    const uint hideCursorAfterSeconds = 3;
    System.Threading.Timer? hideCursorTimer = null;

    bool HideUI
    {
        get
        {
            bool value;
            lock(hideCursorLock)
            {
                value = _hideCursor;
            }
            return value;
        }
        set
        {
            lock(hideCursorLock)
            {
                _hideCursor = value;
            }
        }
    }
    string AddCursorStyle(string css)
    {
        if (HideUI)
            return "cursor: none; " + css;
        else
            return css;
    }

    void HideCursorTick(object? state) {
        ulong incremented = Interlocked.Increment(ref hideCursorTimerSeconds);
        if (incremented >= hideCursorAfterSeconds) // hide cursor timer when enough seconds have elapsed. Timer accuracy is ~1 second.
            HideUI = true;
    }

    void OnMouseMove() => ResetCursorHide();
    void ResetCursorHide()
    {
        Interlocked.Exchange(ref hideCursorTimerSeconds, 0);
        HideUI = false;
    }
    #endregion

    #region Button Handlers
    async Task OpenEffectVisualizer(NDPData data)
    {
        ArgumentNullException.ThrowIfNull(data, nameof(data));

        string serializedData = NDPData.Serialize(data);
        await localStorage.SetItemAsStringAsync("effectVisualizerNDPData", serializedData);

        TrackAudioAnalysis? analysis;
        if (spotify is not null)
            analysis = await spotify.Tracks.GetAudioAnalysis(data.Track.Id);
        else
            analysis = null;

        string serializedAnalysis = analysis is not null ? JsonSerializer.Serialize(analysis) : string.Empty;
        await localStorage.SetItemAsStringAsync("effectVisualizerTrackAnalysis", serializedAnalysis);

        await JSRuntime.InvokeVoidAsync("open", navigationManager.ToAbsoluteUri($"./effectVisualizer").AbsoluteUri, "_blank");
    }

    void OpenSettings()
    {
        // Fix back navigation breaking background gradient by force loading (which makes the app force load when navigating backwards)
        navigationManager.NavigateTo("./settings", forceLoad: true);
    }

    async Task ToggleFullscreen()
    {
        await JSRuntime.InvokeVoidAsync("toggleNDiscoPlusFullscreen", DotNetObjectReference.Create(this));
    }

    async Task TogglePlay()
    {
        if (playStarting)
            throw new InvalidOperationException("Play toggle is already in progress!");

        playStarting = true;

        if (IsPlaying)
            await InternalStopPlaying();
        else
            await InternalStartPlaying();

        playStarting = false;
    }
    #endregion

    #region Lights
    async Task InternalStartPlaying()
    {
        Debug.Assert(hideCursorTimer is null);
        hideCursorTimer = new Timer(HideCursorTick, null, TimeSpan.Zero, TimeSpan.FromSeconds(1));

        await Task.Delay(500);

        LightConfigurationProfile profile = await LightConfigurationProfile.LoadCurrent(localStorage);
        ScreenLightHandler screenLightHandlerSingleton = (ScreenLightHandler)profile.Handlers.Single(lh => lh is ScreenLightHandler);

        bool startSuccessful = true;
        ErrorMessageCollector errors = new();
        List<NDPLight> lights = new();
        foreach (LightHandler handler in profile.Handlers)
        {
            if (await handler.Start(errors, out NDPLight[] startedLights))
                lights.AddRange(startedLights);
            else
                startSuccessful = false;
        }

        if (!startSuccessful)
        {
            logger.LogError("Start unsuccesful.");
            foreach (LightHandler handler in profile.Handlers)
                await handler.Stop();
            await InternalStopPlaying();

            foreach (string error in errors.Collect())
                Snackbar.Add(error, Severity.Error, config => config.RequireInteraction = true);

            return;
        }

        lightHandling = new(profile.Handlers.ToImmutableArray(), lights.ToImmutableArray(), screenLightHandlerSingleton);
    }

    async Task InternalStopPlaying()
    {
        Debug.Assert(hideCursorTimer is not null);
        hideCursorTimer.Dispose();
        hideCursorTimer = null;
        ResetCursorHide();

        await Task.Delay(500);

        if (lightHandling is not null)
        {
            foreach (LightHandler handler in lightHandling.Handlers)
                await handler.Stop();

            lightHandling = null;
        }
    }
    #endregion

    #region Spotify
    async Task StartPlayer()
    {
        if (spotify is null)
            return;

        SpotifyPlayer player = new SpotifyWebPlayer(spotify, playerLogger);

        await foreach (SpotifyPlayerContext? context in player.ListenAsync(targetFps))
        {
            this.context = context;

            if (!IsPlaying)
            {
                interpreterFps = null;
                continue;
            }

            SpotifyPlayerTrack? currentTrack = context?.Track;
            SpotifyPlayerTrack? nextTrack = context?.NextTrack;

            // Update current track light data
            if (lightHandling.CurrentDataTrackId != currentTrack?.Id)
            {
                lightHandling.CurrentDataTrackId = currentTrack?.Id;
                lightHandling.CurrentDataTask = null;
            }
            if (lightHandling.CurrentDataTask is null && lightHandling.CurrentDataTrackId is not null)
            {
                Debug.Assert(currentTrack is not null);
                Debug.Assert(currentTrack.Id == lightHandling.CurrentDataTrackId);

                PaletteGradient? gradient = TryGetTrackGradient(currentTrack);
                if (gradient is PaletteGradient pg)
                    lightHandling.CurrentDataTask = ComputeData(spotify, currentTrack, pg.Palette, lightHandling);
            }

            // Update next track light data
            if (lightHandling.NextDataTrackId != nextTrack?.Id)
            {
                lightHandling.NextDataTrackId = nextTrack?.Id;
                lightHandling.NextDataTask = null;
            }
            if (lightHandling.NextDataTask is null && lightHandling.NextDataTrackId is not null)
            {
                Debug.Assert(nextTrack is not null);
                Debug.Assert(nextTrack.Id == lightHandling.NextDataTrackId);

                PaletteGradient? gradient = TryGetTrackGradient(nextTrack);
                if (gradient is PaletteGradient pg)
                    lightHandling.NextDataTask = ComputeData(spotify, nextTrack, pg.Palette, lightHandling);


            }

            // if current light data has loaded, run interpreter
            if (lightHandling.CurrentData is not null)
            {
                // no CurrentData can be loaded if context?.Track is null
                Debug.Assert(context is not null);

                try
                {
                    LightInterpreterResult result = gradientLights.Update(context.Progress, lightHandling.CurrentData);
                    interpreterFpsFrames.Add(result.FPS);
                    foreach (LightHandler handler in lightHandling.Handlers)
                    {
                        ValueTask updateTask = handler.Update(result);
                        if (!updateTask.IsCompleted)
                            lightHandlerUpdates.Add(updateTask);
                        else
                            await updateTask; // if task is already completed, do not bother adding it to the list and await for any errors instead
                    }

                    while (lightHandlerUpdates.Count > 0 && lightHandlerUpdates[0].IsCompleted)
                    {
                        await lightHandlerUpdates[0]; // await so that we get any errors that might have happened.
                        lightHandlerUpdates.RemoveAt(0);
                    }
                }
                catch (Exception e)
                {
                    logger.LogError($"Lights update failed with error: '{e}'");
                }

                if (interpreterFpsFrames.Count >= interpreterFpsFramesCount)
                {
                    double avgFps = interpreterFpsFrames.Sum() / interpreterFpsFrames.Count;
                    double minFps = interpreterFpsFrames.Min();
                    interpreterFps = new(Average: avgFps, Min: minFps);

                    interpreterFpsFrames.Clear();
                }
            }
            else
            {
                interpreterFps = null;
            }

            StateHasChanged();
        }
    }

    PaletteGradient? TryGetTrackGradient(SpotifyPlayerTrack? track)
    {
        if (track is null)
            return null;

        Task<PaletteGradient?> gradient = trackIdToGradientCache.GetOrAdd(track.Id, _ => FetchImagePaletteGradient(track));
        if (!gradient.IsCompleted)
            return null;
        return gradient.Result;
    }

    async Task<PaletteGradient?> FetchImagePaletteGradient(SpotifyPlayerTrack track)
    {

        Stopwatch sw = Stopwatch.StartNew();
        SerializedValue trackSerialized = SerializedValue.Serialize(track);
        SerializedValue? paletteSerialized = await ndpService!.RunAsync(s => s.FetchImagePaletteBlazorWorker(trackSerialized));
        NDPColorPalette? deserialized = paletteSerialized?.Deserialize<NDPColorPalette>();
        sw.Stop();

        logger.LogInformation("({:0.000} ms) Computed image palette for track: '{}' ({})...", sw.ElapsedMilliseconds, track.Name, track.Id);
        return deserialized.HasValue ? new PaletteGradient(deserialized.Value) : null;
    }

    async Task<NDPData> ComputeData(SpotifyClient spotify, SpotifyPlayerTrack track, NDPColorPalette? referencePalette, LightHandlingData lightHandling)
    {
        TrackAudioFeatures features = await spotify.Tracks.GetAudioFeatures(track.Id);
        TrackAudioAnalysis analysis = await spotify.Tracks.GetAudioAnalysis(track.Id);

        NDiscoPlusArgsLights lights = NDiscoPlusArgsLights.CreateSingleChannel(lightHandling.Lights);
        EffectConfig effects = new();

        NDiscoPlusArgs args = new(track, referencePalette: referencePalette, features, analysis, effects, lights);

        Stopwatch sw = Stopwatch.StartNew();
        SerializedValue argsSerialized = SerializedValue.Serialize(args);
        SerializedValue dataSerialized = await ndpService!.RunAsync(s => s.ComputeDataBlazorWorker(argsSerialized));
        NDPData data = dataSerialized.Deserialize<NDPData>();
        sw.Stop();

        logger.LogInformation("({:0.000} ms) Computed data for track: '{}' ({}).", sw.ElapsedMilliseconds, track.Name, track.Id);
        return data;
    }

    void RequestLogin()
    {
        navigationManager.NavigateTo("./spotify-login");
    }

    async Task LoginSpotify(string refreshToken)
    {
        PKCETokenResponse oauthResp = await new OAuthClient().RequestToken(
            new PKCETokenRefreshRequest(NDPConstants.SpotifyClientId, refreshToken)
        );
        await OnSpotifyTokenRefreshed(oauthResp);

        PKCEAuthenticator authenticator = new(NDPConstants.SpotifyClientId, oauthResp);
        authenticator.TokenRefreshed += async (sender, resp) => await OnSpotifyTokenRefreshed(resp);

        spotify = new SpotifyClient(
            SpotifyClientConfig.CreateDefault()
            .WithAuthenticator(authenticator)
        );
    }

    async Task OnSpotifyTokenRefreshed(PKCETokenResponse response)
    {
        StoredSpotifyRefreshToken? token = await localStorage.GetItemAsync<StoredSpotifyRefreshToken>(LocalStoragePaths.SpotifyRefreshToken);
        if (token?.RefreshToken != response.RefreshToken)
        {
            await localStorage.SetItemAsync(
                LocalStoragePaths.SpotifyRefreshToken,
                new StoredSpotifyRefreshToken(response.RefreshToken, response.Scope.Split(' '))
            );
        }
    }
    #endregion
}
