@page "/"

@using BlazorWorker.BackgroundServiceFactory;
@using BlazorWorker.Core

@using BlazorWorker.WorkerBackgroundService
@using MudBlazor.Utilities
@using NDiscoPlus.Constants
@using NDiscoPlus.Models
@using NDiscoPlus.Shared
@using NDiscoPlus.Shared.Models
@using NDiscoPlus.Shared.Players
@using SkiaSharp
@using SpotifyAPI.Web
@using System.Diagnostics

@inject Blazored.LocalStorage.ILocalStorageService localStorage
@inject NavigationManager navigationManager
@inject ILogger<HomePage> logger;
@inject ILogger<SpotifyWebPlayer> playerLogger;
@inject IWorkerFactory workerFactory;

<PageTitle>NDiscoPlus</PageTitle>

<div style="width:100vw; height:100vh; background: linear-gradient(90deg, @(gradient.TopLeft), @(gradient.TopRight));">
    <div style="position:absolute;top:0;left:0;right:0;bottom:0;background: linear-gradient(90deg, @(gradient.BottomLeft), @(gradient.BottomRight)); mask-image:linear-gradient(to bottom, transparent, black);" />
    <MudStack AlignItems="AlignItems.Center" Justify="Justify.FlexStart" Style="padding-top:20vh;position:absolute;top:0;left:0;right:0;bottom:0;">
        @if(context is not null) {
            <MudImage
                Src="@context.Track.ImageUrl"
                Width="256"
            Height="256"/>
        }
        else
        {
            <div style="background:#1DB954;padding:64px">
                <MudImage
                    Src="/img/spotify_icon_white.svg"
                    Width="128"
                    Height="128"/>
            </div>
        }
        <div style="min-width:256px; max-width:512px;">
            <MudText Style="line-height:1.0; font-size:x-large; white-space:nowrap; overflow:hidden"><b>@(context?.Track.Name ?? "Not Playing...")</b></MudText>
            @if(context is not null)
            {
                <MudText Style="font-size:medium;padding-bottom:1em">@string.Join(", ", context.Track.Artists)</MudText>
            }
        </div>
        <div style="width:80%; max-width:512px; padding-bottom:64px">
            @if(context is not null)
            {
                <MudProgressLinear
                    Value="@(context.Progress.TotalSeconds)"
                    Min="0"
                    Max="@(context.Track.Length.TotalSeconds)"
                    Rounded="true"
                    />
                <MudStack Style="" Row="true" Justify="Justify.SpaceBetween">
                    <MudText Style="line-height:2; font-size:small;">@(context.Progress.ToString(TimespanFormat))</MudText>
                    <MudText Style="line-height:2; font-size:small;">@(context.Track.Length.ToString(TimespanFormat))</MudText>
                </MudStack>
            }
        </div>
        <MudButton
            StartIcon="@Icons.Material.Rounded.Lightbulb"
            Variant="@(isPlaying ? Variant.Outlined : Variant.Filled)"
            Size=Size.Large
            Color=Color.Primary
            Disabled=@(spotify is null || playStarting)
            OnClick=TogglePlay>
            @(isPlaying ? "Stop" : "Play")
        </MudButton>
    </MudStack>
</div>

@code {
    record FourCornerGradient(string TopLeft, string TopRight, string BottomLeft, string BottomRight);
    record NDPData {
        public string? CurrentTrackId { get; set; } = null;
        public NDiscoPlusData? CurrentTrackData { get; set; } = null;
        public string? NextTrackId { get; set; } = null;
        public NDiscoPlusData? NextTrackData { get; set; } = null;
    }

    const string TimespanFormat = @"mm\:ss";

    string? gradientRefUrl = null;
    FourCornerGradient gradient = _defaultGradient;
    static readonly FourCornerGradient _defaultGradient = GetGradient(NDiscoPlusService.DefaultPalettes[0]);

    readonly NDPData data = new();
    List<Task<NDiscoPlusData>> fetchTasks = new();

    bool isPlaying = false;
    bool playStarting = false;

    SpotifyClient? spotify = null;
    SpotifyPlayerContext? context = null;

    IWorkerBackgroundService<NDiscoPlusService>? ndpService = null;

    protected override async Task OnInitializedAsync()
    {
        StoredSpotifyRefreshToken? refreshToken = await localStorage.GetItemAsync<StoredSpotifyRefreshToken>(LocalStoragePaths.SpotifyRefreshToken);
        if (refreshToken is StoredSpotifyRefreshToken rt && NDPConstants.SpotifyScope.All(s => refreshToken.Scope.Contains(s)))
        {
            try
            {
                logger.LogInformation("Spotify login success.");
                await LoginSpotify(rt.RefreshToken);
            }
            catch (Exception e)
            {
                logger.LogError("Spotify login failed with error: '{}'. Requesting new login...", e);
                RequestLogin();
            }
        }
        else
        {
            logger.LogInformation(
                "Requesting new Spotify login.\n- refresh token null: {}\n- old scope: {}\n- new scope: {}",
                refreshToken is null,
                refreshToken is null ? "null" : string.Join(' ', refreshToken.Scope),
                NDPConstants.SpotifyScope
            );
            RequestLogin();
        }

        var ndpWorker = await workerFactory.CreateAsync();
        ndpService = await ndpWorker.CreateBackgroundServiceAsync<NDiscoPlusService>();

        new Task(async () => await StartPlayer(), TaskCreationOptions.LongRunning).Start();
    }

    #region Lights
    async Task TogglePlay()
    {
        playStarting = true;

        if (isPlaying)
        {
            await StopPlaying();
        }
        else
        {
            await StartPlaying();
        }

        playStarting = false;
    }

    async Task StartPlaying()
    {
        await Task.Delay(1000);
        isPlaying = true;
    }

    async Task StopPlaying()
    {
        await Task.Delay(1000);
        isPlaying = false;
    }
    #endregion

    #region Spotify
    async Task StartPlayer()
    {
        if (spotify is null)
            return;

        SpotifyPlayer player = new SpotifyWebPlayer(spotify, playerLogger);
        await foreach(SpotifyPlayerContext? context in player.ListenAsync(50)) {
            this.context = context;
            UpdateData(context?.Track, context?.NextTrack);

            if (!isPlaying)
            {
                NDiscoPlusData? currentTrackData;
                lock(data)
                {
                    currentTrackData = data?.CurrentTrackData;
                }

                if (currentTrackData is not null)
                    gradient = GetGradient(currentTrackData.Palette);
                else
                    gradient = _defaultGradient;
            }

            StateHasChanged();
        }
    }

    void UpdateData(SpotifyPlayerTrack? currentTrack, SpotifyPlayerTrack? nextTrack)
    {
        string? currentTrackId = currentTrack?.Id;
        string? nextTrackId = nextTrack?.Id;


        List<SpotifyPlayerTrack> fetchTracks = new(2);

        lock (data)
        {
            if (data.CurrentTrackId != currentTrackId)
            {
                if (data.NextTrackId == currentTrackId)
                {
                    data.CurrentTrackId = data.NextTrackId;
                    data.CurrentTrackData = data.NextTrackData;
                }
                else
                {
                    data.CurrentTrackId = currentTrackId;
                    if (currentTrack is not null)
                        fetchTracks.Add(currentTrack);
                    data.CurrentTrackData = null;
                }
            }

            if (data.NextTrackId != nextTrackId)
            {
                data.NextTrackId = nextTrackId;
                if (nextTrack is not null)
                    fetchTracks.Add(nextTrack);
                else
                    data.NextTrackData = null;
            }
        }

        foreach (SpotifyPlayerTrack fetch in fetchTracks)
            fetchTasks.Add(ComputeData(fetch));

        foreach (var task in fetchTasks)
        {
            if (!task.IsCompleted)
                continue;

            NDiscoPlusData d = task.Result;
            lock (data)
            {
                if (data.CurrentTrackId == d?.Track.Id)
                    data.CurrentTrackData = d;
                if (data.NextTrackId == d?.Track.Id)
                    data.NextTrackData = d;
            }
        }
    }

    async Task<NDiscoPlusData> ComputeData(SpotifyPlayerTrack track)
    {
        logger.LogInformation("Computing new data for track: '{}' ({})...", track.Name, track.Id);
        string trackSerialized = SpotifyPlayerTrack.Serialize(track);
        string dataSerialized = await ndpService!.RunAsync(s => s.ComputeDataWithImageColorsFromSerialized(trackSerialized));
        var d = NDiscoPlusData.Deserialize(dataSerialized);
        logger.LogInformation("Data computed: '{}' ({}).", track.Name, track.Id);
        return d;
    }

    void RequestLogin()
    {
        navigationManager.NavigateTo("/spotify-login");
    }

    async Task LoginSpotify(string refreshToken)
    {
        PKCETokenResponse oauthResp = await new OAuthClient().RequestToken(
            new PKCETokenRefreshRequest(NDPConstants.SpotifyClientId, refreshToken)
        );
        await OnSpotifyTokenRefreshed(oauthResp);

        PKCEAuthenticator authenticator = new(NDPConstants.SpotifyClientId, oauthResp);
        authenticator.TokenRefreshed += async (sender, resp) => await OnSpotifyTokenRefreshed(resp);

        spotify = new SpotifyClient(
            SpotifyClientConfig.CreateDefault()
            .WithAuthenticator(authenticator)
        );
    }

    async Task OnSpotifyTokenRefreshed(PKCETokenResponse response)
    {
        StoredSpotifyRefreshToken? token = await localStorage.GetItemAsync<StoredSpotifyRefreshToken>(LocalStoragePaths.SpotifyRefreshToken);
        if (token?.RefreshToken != response.RefreshToken)
        {
            await localStorage.SetItemAsync(
                LocalStoragePaths.SpotifyRefreshToken,
                new StoredSpotifyRefreshToken(response.RefreshToken, response.Scope.Split(' '))
            );
        }
    }
    #endregion

    #region Colors
    static FourCornerGradient GetGradient(NDiscoPlusColorPalette palette)
    {
        string[] colors = palette.HtmlColors;

        // By choosing a single color from the image as the background,
        // it seemed to just pick some random color which was barely visible in the image
        // so use default gradient if at least 2 colors can't be decided from the image.
        if (colors.Length < 2)
            return _defaultGradient;
        else if (colors.Length < 4)
            return new FourCornerGradient(colors[0], colors[0], colors[1], colors[1]);
        else
            return new FourCornerGradient(colors[0], colors[1], colors[2], colors[3]);
    }
    #endregion
}
