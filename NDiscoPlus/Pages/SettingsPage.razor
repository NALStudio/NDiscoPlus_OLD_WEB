@page "/settings"
@using System.Collections.Immutable
@using NDiscoPlus.Components
@using NDiscoPlus.Components.Dialogs
@using NDiscoPlus.Components.LightHandlerConfigEditor
@using NDiscoPlus.LightHandlers
@using NDiscoPlus.Models
@using NDiscoPlus.Shared.Helpers
@using NDiscoPlus.Shared.Models
@using System.Diagnostics.CodeAnalysis

@inject NavigationManager navigationManager
@inject Blazored.LocalStorage.ILocalStorageService localStorage;
@inject ILogger<SettingsPage> logger;
@inject IDialogService DialogService

<PageTitle>NDiscoPlus Settings</PageTitle>

<MudAppBar>
    <MudIconButton Icon="@Icons.Material.Rounded.ArrowBack" Color="Color.Inherit" OnClick="NavigateBack" />

    <MudForm Disabled="LockInput.IsLocked">
        <MudStack Row="true" Class="px-4 py-1" Spacing="1" Style="background:#ffffff; margin-left:24px; border-radius:8px" AlignItems="AlignItems.Center">
            <MudSelect T=LightConfigurationProfile Style="width:256px" Value="@currentProfile" ToStringFunc="@(profile => GetProfileName(profile))" ValueChanged="@ChangeProfile" Label="Profile">
                @foreach (LightConfigurationProfile profile in profiles)
                {
                    <MudSelectItem T="LightConfigurationProfile" Value=@profile />
                }
            </MudSelect>
            <MudIconButton Icon="@Icons.Material.Rounded.Edit" OnClick="ChangeCurrentProfileName" />

            <MudDivider Style="height:48px; margin-right:8px" Vertical="true" />

            @{
                ImmutableArray<LightHandlerImplementation> validImplementations;
                if (currentProfile is not null)
                    validImplementations = ImplementationsThatCanBeAddedTo(currentProfile).ToImmutableArray();
                else
                    validImplementations = ImmutableArray<LightHandlerImplementation>.Empty;
            }
            <MudMenu Disabled="@(currentProfile is null || validImplementations.Length < 1)" Icon="@Icons.Material.Rounded.Add">
                @if (currentProfile is not null)
                {
                    @foreach (LightHandlerImplementation impl in validImplementations)
                    {
                        <MudMenuItem OnClick="@(() => AddHandler(impl))">@(impl.DisplayName)</MudMenuItem>
                    }
                }
            </MudMenu>
            <MudIconButton Icon="@Icons.Material.Rounded.Save" Disabled="@(!CurrentProfileEdited)" OnClick="SaveCurrentProfile" />
        </MudStack>
    </MudForm>

    <MudSpacer />

    <!-- TODO: Temporary icon, use logo instead. -->
    <MudIcon Icon="@Icons.Material.Rounded.Lightbulb" Color="Color.Inherit" />
</MudAppBar>

<MudMainContent Class="mt-16 pa-4">
    @if (currentProfile is not null)
    {
        <MudForm @ref=form @bind-IsTouched=_formIsTouched Disabled="LockInput.IsLocked">
            <MudExpansionPanels>
                <MudExpansionPanel Class="mud-theme-primary" HideIcon="true">
                    <TitleContent>
                        <MudStack Row="true" AlignItems="AlignItems.Center">
                            <!-- Set margin and padding to center the text vertically -->
                            <MudText><h5 style="margin:0;padding:0">Light Configuration</h5></MudText>
                            <MudSpacer />
                            @if (currentProfileLights.Count > 0)
                            {
                                <MudBadge Content="@(currentProfileLights.Count)">
                                    <MudIcon Icon="@(Icons.Material.Rounded.Lightbulb)" Color="Color.Warning" />
                                </MudBadge>
                            }
                            <MudIconButton Icon="@(Icons.Material.Rounded.Refresh)" Color="Color.Inherit" />
                        </MudStack>
                    </TitleContent>
                </MudExpansionPanel>
            </MudExpansionPanels>

            <div style="height:24px; align-content:center;">
                <MudDivider />
            </div>

            <MudExpansionPanels MultiExpansion="true">
                @foreach (LightHandler handler in currentProfile.Handlers)
                {
                    LightHandlerConfig config = handler.ConfigRef;
                    var parameters = LightHandlerConfigEditor<LightHandlerConfig>.CreateParametersDictionary(config);
                    Type editorType = config.GetEditorType();

                    <MudExpansionPanel>
                        <TitleContent>
                            <div class="d-flex">
                                <MudIcon Icon="@(handler.Implementation.DisplayIcon)" Class="mr-3" />
                                <MudText><strong>@(handler.Implementation.DisplayName)</strong></MudText>
                            </div>
                        </TitleContent>
                        <ChildContent>
                            <!-- If object could not be instantiated, one common cause can be that object does not inherit LightHandlerConfigEditor<T> -->
                            <DynamicComponent Type="editorType" Parameters="@parameters" />
                        </ChildContent>
                    </MudExpansionPanel>
                }
            </MudExpansionPanels>
        </MudForm>
    }
</MudMainContent>

<MudMessageBox @ref=_mudMessageBox Title="Unsaved Changes!" CancelText="Cancel">
    <MessageContent>
        There are unsaved messages.
        Are you sure you want to discard them?
    </MessageContent>
    <YesButton>
        <MudButton Color="Color.Error">Discard</MudButton>
    </YesButton>
</MudMessageBox>

@code {
    private readonly struct LockInput : IDisposable
    {
        private static readonly List<LockInput> _locks = new();
        public static bool IsLocked => _locks.Count > 0;

        private readonly SettingsPage parentRef;
        private LockInput(SettingsPage parentRef)
        {
            this.parentRef = parentRef;
        }

        public static LockInput Lock(SettingsPage parentRef)
        {
            LockInput handle = new(parentRef);

            _locks.Add(handle);
            parentRef.StateHasChanged();

            return handle;
        }

        public void Dispose()
        {
            _locks.Remove(this);
            parentRef.StateHasChanged();
        }
    }


    private readonly List<LightConfigurationProfile> profiles = new();

    private LightConfigurationProfile? currentProfile;
    private readonly List<NDPLight> currentProfileLights = new();

    private HashSet<int> _expandedHandlerSettings = new();

    private MudMessageBox? _mudMessageBox;

    private MudForm? form;

    private bool _formIsTouched = false;
    private bool __currentProfileEdited = false;
    private bool CurrentProfileEdited
    {
        get => _formIsTouched || __currentProfileEdited;
        set
        {
            if (!value)
                throw new ArgumentException("Cannot set value as false.");
            __currentProfileEdited = true;
        }
    }

    private IEnumerable<LightHandlerImplementation> ImplementationsThatCanBeAddedTo(LightConfigurationProfile? profile)
    {
        if (profile is null)
            yield break;

        foreach (LightHandlerImplementation impl in LightHandler.Implementations)
        {
            if (profile.CanAddHandler(impl))
                yield return impl;
        }
    }

    protected override async Task OnInitializedAsync()
    {
        await ReloadProfiles();
    }

    private bool HandlerIsExpanded(int index) => _expandedHandlerSettings.Contains(index);
    private void ExpandHandler(int index, bool expand)
    {
        if (expand)
            _ = _expandedHandlerSettings.Add(index);
        else
            _ = _expandedHandlerSettings.Remove(index);
    }

    private string GetProfileName(LightConfigurationProfile profile)
        => string.IsNullOrWhiteSpace(profile.Name) ? "Unnamed Profile" : profile.Name;

    private async Task ReloadProfiles()
    {
        using (LockInput.Lock(this))
        {
            // profiles are sorted in alphabetical order by their name

            // load current before loading all profiles so that the current profile is included in all profiles
            LightConfigurationProfile currentProfile = await LightConfigurationProfile.LoadCurrent(localStorage);

            profiles.Clear();
            await foreach (LightConfigurationProfile profile in LightConfigurationProfile.LoadAll(localStorage))
                Bisect.InsortRight(profiles, profile, keySelector: p => p.Name);

            // get current profile from list so that we only have a single instance of all profiles
            this.currentProfile = profiles.Single(p => p.UniqueId == currentProfile.UniqueId);
        }
    }

    private async Task<bool> CanDiscardCurrentProfile()
    {
        if (!CurrentProfileEdited)
            return true;

        bool? result = await _mudMessageBox!.ShowAsync();
        return result == true;
    }

    private async Task SaveCurrentProfile()
    {
        ThrowIfCurrentProfileIsNull();

        using (LockInput.Lock(this))
        {
            await Task.Delay(500);

            await LightConfigurationProfile.Save(localStorage, currentProfile);
            __currentProfileEdited = false;
            form!.ResetTouched();
            _formIsTouched = false;
        }
    }

    private async Task ChangeProfile(LightConfigurationProfile newProfile)
    {
        if (newProfile == currentProfile)
            return;

        using (LockInput.Lock(this))
        {
            if (!(await CanDiscardCurrentProfile()))
                return;

            await LightConfigurationProfile.SaveAsCurrent(localStorage, newProfile);
            await ReloadProfiles(); // ReloadProfiles sets the new currentProfile reference
            await ReloadLights();
        }
    }

    private async Task ReloadLights()
    {
        using (LockInput.Lock(this))
        {
            ThrowIfCurrentProfileIsNull();

            currentProfileLights.Clear();

            foreach (LightHandler handler in currentProfile.Handlers)
            {
                bool configValid = await handler.ValidateConfig(null);
                if (!configValid)
                    continue;

                currentProfileLights.AddRange(await handler.GetLights());
            }
        }
    }

    private async Task ChangeCurrentProfileName()
    {
        ThrowIfCurrentProfileIsNull();

        string initialText = currentProfile.Name;
        DialogParameters<RenameProfileDialog> parameters = new()
        {
            { p => p.InitialText, initialText }
        };

        DialogResult? res = await DialogService.Show<RenameProfileDialog>("Rename Profile", parameters).Result;
        if (res?.Data is string name)
        {
            currentProfile.Name = name;
            CurrentProfileEdited = true;
        }
    }

    private void AddHandler(LightHandlerImplementation implementation)
    {
        ThrowIfCurrentProfileIsNull();

        currentProfile.AddHandler(implementation.Type);
        CurrentProfileEdited = true;
    }

    private async Task NavigateBack()
    {
        if (!(await CanDiscardCurrentProfile()))
            return;

        navigationManager.NavigateTo("..", forceLoad: true);
    }

    [MemberNotNull(nameof(currentProfile))]
    private void ThrowIfCurrentProfileIsNull()
    {
        if (currentProfile is null)
            throw new InvalidOperationException("No current profile loaded.");
    }
}
